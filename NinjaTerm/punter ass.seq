;**************************************************;*                                                *;*      T E R M . C 1  (NEW PUNTER PROTOCOL)      *;*      ------------------------------------      *;*                                                *;*               SOURCE = S/TERM.C1               *;*               OBJECT = O/TERM.C1               *;*                                                *;*   THIS NEW PUNTER PROTOCOL FEATURES ADJUST-    *;* ABLE DATA LENGTH (40-255 BYTES), NEW HAND-     *;* SHAKING SIGNALS, AND FASTER UP/DOWNLOADS.      *;*                                                *;*    - COMMENTED DISASSEMBLY  BY TOM HUGHES -    *;*                                                *;*                    V081284                     *;*                                                *;**************************************************.SKIP;;C-64 EQUATES;.SKIPZ62    = $62 ;SYS JUMP VALUE/COUNTERZ64    = $64 ;BUFFER POINTER-LOZ65    = $65 ;  ''     ''   -HIZ96    = $96 ;PSUEDO-ST REGISTER;                         0 = OK;                         1 = ALL BYTES RECEIVED ???;                         2 = RECEIVE BUFFER EMPTY;                         4 = SOME BYTES RECEIVED;                         8 = $C806/C807 = 0ZBA    = $BA ;CURRENT DEVICE #ZF7    = $F7 ;RS-232 INPUT BUFFER POINTER-LOZF8    = $F8 ;  ''     ''    ''      ''  -HI.SKIPX0200  = $0200 ;RS-232 BYTE/FLAG: BLOCK SIZEX028D  = $028D ;KEYBRD FLAG: 2 = CMDR PRESSEDX029B  = $029B ;PTR: END OF RS-232 INPUT BUFFERX029C  = $029C ;PTR: START   ''      ''    ''X02A1  = $02A1 ;RS-232 ENABLES.SKIPRS2SET = $EF7E ;ENABLE RS-232 BYTE RECEPTIONCHKIN  = $FFC6 ;READY CHANNEL FOR OUTPUTCHRIN  = $FFCF ;INPUT CHAR TO CHANNELCHKOUT = $FFC9 ; ''     ''     '' INPUTCHROUT = $FFD2 ;OUTPUT CHAR TO CHANNELCLRCHN = $FFCC ;I/O TO DEFAULT (SCREEN)GETIN  = $FFE4 ;GET CHAR FROM KEYBOARDREADST = $FFB7 ;READ/CLEAR I/O STATUS WORD.PAGE 'PROGRAM STORAGE'XC800  = $C800 ;3-LETTER HANDSHAKEXC801  = $C801 ;    ''       ''XC802  = $C802 ;    ''       ''XC803  = $C803 ;SC051 LOOP COUNTER (1,2,4,8,16,32)XC804  = $C804 ;SC051 HANDSHAKE PTR (0,3,6,9,12 OR 15)XC805  = $C805 ;SC051 ENTRY VALUE (0,4,8,11 OR 16)XC806  = $C806 ;SC051/SC27F FLAG: $FF=HSHAKE REC'DXC807  = $C807 ;    ''       ''         ''XC808  = $C808 ;HANDSHAKE INDEX (0,3,6,8,12)XC809  = $C809 ;# BYTES IN BLOCK/COUNTER ???XC80A  = $C80A ;(UNUSED)XC80B  = $C80B ;DELAY FLAG: 0=NO DELAY IF $C80C < 3XC80C  = $C80C ;SC55E COUNTER (0-3)XC80D  = $C80D ;REC/XMIT FLAG: 0 = 1ST BLOCKXC80E  = $C80E ;SC484 CHECKSUM WORKSPACEXC80F  = $C80F ;  ''     ''       ''XC810  = $C810 ;  ''     ''       ''XC811  = $C811 ;  ''     ''       ''XC812  = $C812 ;SC380 CHECKSUM WORKSPACEXC813  = $C813 ;  ''     ''       ''XC814  = $C814 ;  ''     ''       ''XC815  = $C815 ;  ''     ''       ''XC816  = $C816 ;$64/65 OFFSETXC817  = $C817 ;# BYTES TO SEND (SET BY $C904) ???XC818  = $C818 ;BLOCK SIZE (40-255)XC819  = $C819 ;COUNTER/FLAG: $FF FOR XMIT START ???XC81A  = $C81A ;      ''XC81B  = $C81B ;FILETYPE (1=PRG, 2=SEQ, 3=WORDPRO)XC81C  = $C81C ;ENTRY STACK POINTERXC81D  = $C81D ;XMIT FLAG: 0=SHORT BLK/1=LONG BLKXC81E  = $C81E ;XMIT FLAG: 0=SEND "GOO"/1=SEND "SYN".SKIP 2;;BLOCK HEADER FORMAT ($C900=REC BUFF/$CA00=XMIT BUFF);.SKIPXC900  = $C900 ;CHECKSUM 1 - SUMXC901  = $C901 ;    ''       ''XC902  = $C902 ;CHECKSUM 2 - EORXC903  = $C903 ;    ''       ''XC904  = $C904 ;# BYTES IN HEADER (7)XC905  = $C905 ;# BYTES IN BLOCK ???XC906  = $C906 ;ERROR FLAG: $FF=???XC907  = $C907 ;FILETYPE (1-3).PAGE 'JUMPS & DATA'* = $C000 ;START @ 49152.SKIP;;SYS "ADJUSTABLE" JUMP VALUES;.SKIPLDA #0 ;SYS 49152.BYT $2CLDA #3 ;SYS 49155 (RECEIVE DATA-2).BYT $2CLDA #6 ;SYS 49158 (TRANSMIT DATA-2).BYT $2CLDA #9 ;SYS 49161 (RECEIVE DATA-1).BYT $2CLDA #12 ;SYS 49164 (TRANSMIT DATA-1).BYT $2CLDA #15 ;SYS 49167 (TERMINAL MODE)NOPJMP JC018 ;SET ADJUSTABLE JUMP.SKIPJMP SC59B ;SYS 49173 (RS-232 SETTUP).SKIPJC018 STA Z62 ;(0,3,6,9,12,15)TSXSTX XC81C ;SAVE CURRENT STACK PTRLDA #$30CLCADC Z62STA ADJUMP+1 ;SET JUMP-LOLDA #>ADJUMPADC #0STA ADJUMP+2 ;SET JUMP-HIADJUMP JMP $0000.SKIP;;JUMP TABLE;JMP SC051 ;(SYS 49152)JMP SC408 ;RECEIVE 2 (SYS 49155)JMP SC3D0 ;TRANSMIT 2 (SYS 49158)JMP SC4CE ;RECEIVE 1 (SYS 49161)JMP SC517 ;TRANSMIT 1 (SYS 49164)JMP SC5AA ;TERMINAL MODE (SYS 49167).SKIP;;HANDSHAKE SIGNALS (SENT BY SC124);HSHAKE = * ;INDEXED BY .Y & $C808.BYT 'GOO' ;.Y = 0  (GO)  ???.BYT 'BAD' ;.Y = 3  (BAD BLOCK).BYT 'ACK' ;.Y = 6  (ACKNOWLEDGE).BYT 'S/B' ;.Y = 9  (SEND BLOCK) ???.BYT 'SYN' ;.Y = 12 (BBS READY) ???.PAGE 'RECEIVE HANDSHAKE';----------------------------------------;SC151: CHECK FOR BBS HANDSHAKE;----------------------------------------.SKIP;ENTRY: IF .A = 0, DON'T CHECK ANY;               4, CHECK FOR "ACK" ONLY;               8,   ''   '' "S/B"  '';              11,   ''   '' "GOO", "BAD", OR "S/B";              16,   ''   '' "SYN" ONLY;EXIT: IF RECEIVED, $96 = 0 & $C806/C807 = 0;      IF NOT, $96 = 1.SKIPSC051 STA XC805 ;SAVE ENTRY VALUELDA #0 ;CLEAR HANDSHAKE STORAGESTA XC800STA XC801STA XC802.SKIPJC05F LDA #0 ;CLEAR COUNTERS/FLAGSSTA XC806STA XC807JC067 JSR SC67B ;CMDR KEY PRESSED? (IF YES,EXIT)JSR SC0F2 ;GET BYTE FROM RS-232 BUFFERLDA Z96 ;BYTE IN BUFFER?BNE BC0C9LDA XC801 ;YES, STORE @ $C800-C802STA XC800LDA XC802STA XC801LDA X0200 ;RS-232 BYTESTA XC802LDA #0STA XC804 ;HANDSHAKE WORD PTR = 0LDA #1STA XC803 ;SET LOOP COUNTER.SKIP;VALIDATE BBS HANDSHAKE;BC08D LDA XC805 ;(= 0,4,8,11 OR 16)BIT XC803 ;(= 1,2,4,8,16 OR 32)BEQ BC0AB ;IF EQUAL, DON'T CHECK HSHAKELDY XC804LDX #0BC09A LDA XC800,X ;ELSE GET BBS HANDSHAKE WORDCMP HSHAKE,Y ;SAME AS TABLE?BNE BC0ABINYINXCPX #3BNE BC09AJMP JC0BE ;YES, SET FLAGS & GET MORE BYTES.PAGEBC0AB ASL XC803 ;TIMES 2 (= 2,4,8,16 OR 32)LDA XC804 ;SET TO NEXT HANDSHAKE WORDCLCADC #3STA XC804 ;BUMP INDEX BY 3CMP #15 ;LAST WORD?BNE BC08DJMP JC05F ;YES, TRY AGAIN.SKIP;HANDSHAKE RECEIVED FROM BBS;JC0BE LDA #$FF ;SET FLAGSSTA XC806STA XC807JMP JC067 ;AND GET MORE BYTES.SKIP;RS-232 INPUT BUFFER EMPTY ($96 = 2);BC0C9 INC XC806 ;BUMP COUNTERS/FLAGSBNE BC0D1INC XC807BC0D1 LDA XC807ORA XC806 ;HANDSHAKE RECEIVED?BEQ BC0EC ;YES, EXITLDA XC806CMP #7 ;???LDA XC807CMP #20 ;HI-COUNT < 20?BCC JC067.SKIPLDA #1 ;NO, SET FLAG: HSHAKE REC'DSTA Z96JMP SC55E ;DELAY/EXIT.SKIPBC0EC LDA #0 ;FLAG: HSHAKE RECEIVEDSTA Z96RTS.PAGE 'INPUT RS-232 BYTE';----------------------------------------;SC0F1: GET BYTE FROM RS-232 BUFFER;----------------------------------------.SKIP;EXIT:  IF BYTE, $0200 = BYTE/$96 = 0;       IF NO BYTE, $0200 = 0/$96 = 2.SKIPSC0F1 NOPSC0F2 TYA ;PRESERVE .YPHALDA X029BCMP X029C ;INPUT BUFFER EMPTY?BEQ BC112LDY X029CLDA (ZF7),Y ;NO, GET BYTE FROM BUFFERPHA ;SAVEINC X029C ;BUMP BUFFER POINTERLDA #0STA Z96 ;SET FLAG = 0PLASTA X0200 ;STORE BYTEPLATAY ;RESTORE .YJMP JC11D.SKIP;RS-232 BUFFER EMPTY;BC112 LDA #2STA Z96 ;SET FLAG = 2LDA #0STA X0200 ;STORE NULL BYTEPLATAY ;RESTORE .Y.SKIPJC11D PHA ;PRESERVE .YLDA #3STA ZBA ;SCREEN = CURRENT DEVICEPLA ;RESTORE .YRTS.PAGE 'SEND HANDSHAKE';----------------------------------------;SC124: SEND HANDSHAKE TO BBS;----------------------------------------.SKIP;ENTRY:  IF .Y = 0, "GOO";          ''    3, "BAD";          ''    6, "ACK";          ''    9, "S/B";          ''   12, "SYN".SKIPSC124 LDX #5 ;READY MODEM FOR OUTPUTJSR CHKOUTLDX #0BC12B LDA HSHAKE,YJSR CHROUT ;HANDSHAKE -> MODEMINYINXCPX #3 ;SEND 3 BYTESBNE BC12BJMP CLRCHN ;I/O TO DEFAULTS, EXIT.SKIP 2;----------------------------------------;SC13A: SEND HANDSHAKE, GET DATA @ $C900;----------------------------------------.SKIP;ENTRY:  .A = HANDSHAKE WORD INDEX (SEE ABOVE);             (0=1ST BLOCK/1=ALL OTHERS).SKIPSC13A STA XC808 ;SAVE INDEXLDA #0STA XC80B ;FLAG: DELAY/EXIT IF $C80C > 2JC142 LDA #2STA Z62 ;SET ATTEMPT COUNTERLDY XC808JSR SC124 ;SEND HANDSHAKEBC14C LDA #4JSR SC051 ;WAIT FOR BBS "ACK"LDA Z96 ;RECEIVED?BEQ BC15CDEC Z62BNE BC14CJMP JC142 ;NO, TRY AGAIN.PAGE;BBS "ACK" RECEIVED;BC15C LDY #9JSR SC124 ;SEND "S/B" TO BBSLDA XC80D ;FLAG: 1ST BLOCK?BEQ BC16BLDA XC808 ;FLAG: LAST HSHAKE = "GOO"?BEQ BC18A ;YES, BRANCH.SKIP;RECEIVE 1ST BLOCK (8 BYTES);BC16B LDA XC904 ;# OF BYTES TO RECEIVE (8=START)STA XC809STA XC817JSR SC27F ;RECEIVE BBS DATA @ $C900LDA Z96CMP #1 ;ALL BYTES RECEIVED?BEQ BC189 ;YES, EXITCMP #2 ;RECEIVE BUFFER EMPTY?BEQ BC15C ;YES, SEND "S/B" AGAINCMP #4 ;1 OR MORE BYTES RECEIVED?BEQ BC189 ;YES, EXITCMP #8 ;COUNTERS AT MAX?BEQ BC15C ;YES, SEND "S/B" AGAINBC189 RTS ;$96 = 1 OR 4.SKIP;FLAG $C80D = 0 ("GOO");BC18A LDA #16JSR SC051 ;WAIT FOR BBS "SYN"LDA Z96 ;RECEIVED?BNE BC15C ;NO, SEND "S/B" AGAIN.SKIPLDA #10STA XC809BC198 LDY #12JSR SC124 ;YES, SEND "SYN" TO BBSLDA #8JSR SC051 ;WAIT FOR  "S/B"LDA Z96 ;RECEIVED?BEQ BC1ABDEC XC809 ;NO, ATTEMPT 10 TIMESBNE BC198BC1AB RTS ;$96 = 0 OR 1.PAGE 'BUFFER -> BBS';----------------------------------------;SC1AC:  SEND $C809 BYTES -> BBS;----------------------------------------.SKIP;EXIT: IF .A = 0, GOOD BLOCK;        ''    1, BAD BLOCK/LAST BLK ???.SKIPSC1AC LDA #1STA XC80B ;FLAG: DELAY/EXITBC1B1 LDA XC81E ;FLAG: 1=SEND "GOO"/0=NO "GOO"BEQ BC1BBLDY #0JSR SC124 ;SEND "GOO"BC1BB LDA #11JSR SC051 ;WAIT FOR "GOO", "BAD" OR "S/B"LDA Z96 ;ONE RECEIVED?BNE BC1B1 ;NO, TRY AGAIN.SKIP;EITHER "GOO", "BAD" OR "S/B" RECEIVED;LDA #0STA XC81E ;FLAG: 0=NO "GOO"LDA XC804 ;WAS "GOO" RECEIVED?CMP #0BNE BC205 ;NO, PRINT ":", SEND "ACK" & HEADER, EXIT.SKIP;"GOO" RECEIVED;LDA XC80D ;FLAG: 1ST BLOCK?BNE BC23D ;YES, PRINT "*", SEND "ACK" & "S/B",EXITINC XC819 ;(= 0 FOR 1ST BLK)BNE BC1DDINC XC81A ;(= 0 FOR 1ST BLK)BC1DD JSR SC364 ;SET $64/65 = $CA00LDY #5INYLDA (Z64),Y ;$CA06 = $FF? (START?)CMP #$FFBNE BC1FF ;NO, DISK -> BUFFERLDA #1STA XC80D ;FLAG: NOT 1ST BLOCKLDA XC816EOR #%00000001STA XC816 ;RESET $64/65 = $C900JSR SC364JSR SC344 ;COMPUTE BLOCK CHECKSUMJMP JC202 ;SEND "ACK" & $C809 BYTES.PAGE;DISK -> BUFFER  ($C906/CA06 <> $FF);BC1FF JSR SC2FF ;DISK -> BUFFERJC202 LDA #'- ;"-" = GOOD BLOCK.BYT $2CBC205 LDA #': ;":" = BAD BLOCKJSR SC586 ;PRINT "-" OR ":" (IF $C80D = 0)LDY #6JSR SC124 ;SEND "ACK"LDA #8JSR SC051 ;WAIT FOR BBS "S/B"LDA Z96 ;RECEIVED?BNE JC202 ;NO, TRY AGAIN.SKIP;BBS "S/B" RECEIVED, SEND $C809 BYTES;JSR SC364 ;SET $64/65 = $CA00 ???LDY #4LDA (Z64),Y ;GET # OF BYTES IN HEADERSTA XC809 ;SAVEJSR SC371 ;SET $64/65 = $C900 ???LDX #5JSR CHKOUT ;READY MODEM FOR OUTPUTLDY #0BC22C LDA (Z64),Y ;$C809 BYTES -> BBSJSR CHROUTINYCPY XC809 ;# BYTES IN HEADER ???BNE BC22CJSR CLRCHN ;I/O TO DEFAULTLDA #0RTS.PAGE;SEND SHORT BLOCK "*" ???;ENTRY: $C80D <> 0;BC23D LDA #'*JSR SC586 ;PRINT "*"LDY #6JSR SC124 ;SEND "ACK" TO BBSLDA #8JSR SC051 ;WAIT FOR BBS HSHAKE (EXCEPT "S/B")LDA Z96 ;RECEIVED?BNE BC23D ;NO, SEND AGAIN.SKIP;BBS HANDSHAKE RECEIVED;LDA #10STA XC809BC255 LDY #11JSR SC124 ;SEND "SYN" TO BBSLDA #16JSR SC051 ;WAIT FOR BBS HSHAKE (EXCEPT "SYN")LDA Z96 ;RECEIVED?BEQ BC268DEC XC809 ;N0, TRY 10 TIMESBNE BC255.SKIP;BBS HANDSHAKE RECEIVED;BC268 LDA #3STA XC809 ;SET ATTEMPT COUNTERBC26D LDY #9JSR SC124 ;SEND "S/B" 3 TIMESLDA #0JSR SC051 ;WAIT FOR ANY BBS HANDSHAKEDEC XC809 ;-1 FROM ATTEMPT COUNTERBNE BC26DLDA #1 ;FLAG: ERROR ???RTS.PAGE 'BBS -> BUFFER';----------------------------------------;SC27F: RECEIVE BBS DATA @ $C900;----------------------------------------.SKIPSC27F LDY #0BC281 LDA #0STA XC806 ;CLEAR ATTEMPT COUNTERSSTA XC807JC289 JSR SC67B ;CMDR KEY PRESSED?JSR SC0F2 ;NO, GET RS-232 BUFFER BYTELDA Z96 ;BYTE IN BUFFER?BNE BC2CF ;NO, BUMP ATTEMPT COUNT.SKIP;RS-232 BYTE RECEIVED;LDA X0200 ;GET MODEM BYTESTA XC900,YCPY #3 ;3 HANDSHAKE BYTES RECEIVED?BCS BC2B9 ;YES, SKIP.SKIPSTA XC800,YCPY #2BNE BC2B9LDA XC800 ;FIRST 3 BYTES = "ACK"?CMP #'ABNE BC2B9LDA XC801CMP #'CBNE BC2B9LDA XC802CMP #'KBEQ BC2C4 ;YES, BRANCH.SKIPBC2B9 INYCPY XC809 ;ALL BYTES RECEIVED?BNE BC281LDA #1 ;YES, SET FLAG = 1STA Z96RTS.SKIP;"ACK" RECEIVED @ $C800-C802;BC2C4 LDA #$FFSTA XC806 ;SET FLAGS TO MAXSTA XC807JMP JC289 ;GET MORE BYTES.PAGE;HANDLE $96 <> 0;BC2CF INC XC806 ;BUMP LO-COUNTERBNE BC2D7INC XC807 ;BUMP HI-COUNTERBC2D7 LDA XC806ORA XC807 ;COUNTERS AT MAX?BEQ BC2FALDA XC806CMP #6 ;???LDA XC807CMP #16 ;NO, HI-COUNTER < 16?BNE JC289 ;YES, TRY AGAINLDA #2STA Z96 ;IF NO BYTES, $96 = 2CPY #0BEQ BC2F7LDA #4 ;IF 1+ BYTES, $96 = 4STA Z96BC2F7 JMP SC55E ;DELAY & EXIT.SKIPBC2FA LDA #8 ;IF COUNTERS = 0, $96 = 8STA Z96RTS.PAGE;----------------------------------------;SC2FF:  DISK -> BUFFER;----------------------------------------.SKIPSC2FF LDA XC816 ;CHANGE CURRENT BUFFEREOR #%00000001STA XC816JSR SC364 ;SET $64/65 = $CA00 ???LDY #5LDA XC819 ;L-ADDRESS SEND BUFFER ???CLCADC #1 ;+1STA (Z64),Y ;SAVE @ $CA05/C905 ???INYLDA XC81A ;H-ADDRESS SEND BUFFER ???ADC #0STA (Z64),Y ;SAVE @ $CA06/C906 ???LDX #2JSR CHKIN ;READY CH 2 FOR INPUT (DISK)LDY #7BC323 JSR CHRIN ;GET DISK BYTESTA (Z64),Y ;SAVE  @ $CA07 ON ...INYJSR READST ;ST = 0?BNE BC338CPY XC818 ;$C818 BYTES RECEIVED?BNE BC323TYAPHA ;PRESERVE BUFFER POINTERJMP JC345.SKIP;ST <> 0;BC338 TYAPHA ;PRESERVE BUFFER POINTERLDY #5INYLDA #$FFSTA (Z64),Y ;SET $CA06 = $FFJMP JC345.PAGE 'CHECKSUM';----------------------------------------;SC344: COMPUTE BLOCK CHECKSUM;----------------------------------------.SKIP;ENTRY: .A = $C804 (HANDSHAKE WORD INDEX);EXIT:  $C809 = # BYTES IN BLOCK;       $C904 =     ''    ''   ???;       CHECKSUM IN HEADER @ XX00-XX03.SKIPSC344 PHA ;SAVE INDEX.SKIPJC345 JSR CLRCHN ;I/O TO DEFAULTSJSR SC59B ;ENABLE BYTE RECEPTIONJSR SC579 ;DELAY LOOPJSR SC59B ;ENABLE BYTE RECEPTIONLDY #4LDA (Z64),Y ;GET # OF BYTES IN BLOCKSTA XC809 ;SAVEJSR SC371 ;SET $64/65 = $C900PLA ;GET BUFFER POINTERLDY #4STA (Z64),Y ;SAVE AS # BYTES IN BLOCKJSR SC380 ;COMPUTE BLOCK CHECKSUMRTS.PAGE 'SET $64/65';----------------------------------------;SC364: SET $64/65 - ASCENDING;----------------------------------------.SKIP;ENTRY: IF $C816 = 0, $64/65 = $C900;            ''    1,   ''     $CA00.SKIPSC364 LDA #0STA Z64LDA XC816 ;POINTER OFFSETCLCADC #$C9 ;$C816 + $C9 = $65STA Z65RTS.SKIP 2;----------------------------------------;SC371: SET $64/65 - CHANGE BUFFER;----------------------------------------.SKIP;ENTRY: IF $C816 = 0, $64/65 = $CA00;             ''   1,    ''    $C900.SKIPSC371 LDA #0STA Z64LDA XC816 ;POINTER OFFSETEOR #%00000001 ;CHANGE BUFFERCLCADC #$C9STA Z65RTS.PAGE 'CHECKSUM 2';----------------------------------------;SC380: COMPUTE BLOCK CHECKSUM;----------------------------------------.SKIP;ENTRY: $C809 = # BYTES IN BLOCK;EXIT:  $C814-C815 CONTAINS CHECKSUM;       $C902-C903    ''       ''     ???.SKIPSC380 LDA #0STA XC812 ;CHECKSUM 1 - SUM OF BYTESSTA XC813STA XC814 ;CHECKSUM 2 - EOR OF BYTESSTA XC815LDY #4 ;CHECKSUM FROM $C904 ON IN BLKBC390 LDA XC812CLCADC (Z64),YSTA XC812BCC BC39EINC XC813BC39E LDA XC814EOR (Z64),YSTA XC814LDA XC815ROL A ;$C815 CARRY -> BIT 0ROL XC814 ;$C814 CARRY -> BIT 0ROL XC815 ;$C815      ''INYCPY XC809 ;END OF BLOCK?BNE BC390.SKIPLDY #0LDA XC812 ;CHECKSUM 1 -> $C900/C901STA (Z64),YINYLDA XC813STA (Z64),YINYLDA XC814 ;CHECKSUM 2 -> $C902/C903STA (Z64),YINYLDA XC815STA (Z64),YRTS.PAGE 'TRANSMIT 2';========================================;SC3D0: TRANSMIT 2 - BUFFER TO BBS;========================================.SKIP;EXIT: $0200 = 0.SKIPSC3D0 LDA #0STA XC80D ;FLAG: 1ST BLOCK?STA XC80C ;DELAY COUNTERSTA XC81D ;SHORT BLK # BYTES ???LDA #1STA XC816 ;TRANSMIT BUFFER @ $CA00LDA #$FFSTA XC819 ;SET FOR XMITSTA XC81AJSR SC371 ;SET $64/65 = $C900LDY #4LDA #7STA (Z64),Y ;$C904 = 7 (# HEADER BYTES)JSR SC364 ;SET $64/65 = $CA00LDY #5LDA #0STA (Z64),Y ;$CA05 = 0 (# BLOCK BYTES-LO)INYSTA (Z64),Y ;$CA06 = 0 (# BLOCK BYTES-HI)BC3FD JSR SC1AC ;BLOCK(S) -> BBS ... ???BEQ BC3FDBC402 LDA #0STA X0200 ;FLAG: END OF TRANSMISSIONRTS.PAGE 'RECEIVE 2';========================================;SC408: RECEIVE 2 - BUFFER TO DISK;========================================.SKIPSC408 LDA #1STA XC819 ;FLAG: RECEIVE ???LDA #0STA XC81A ;???STA XC80D ;FLAG: 1ST BLOCKSTA XC816 ;RECEIVE BUFFER @ $C900STA XC905 ;# BYTES IN BLOCK  ???STA XC906 ;FLAG: $FF = SHORT BLK ???STA XC80C ;DELAY COUNTERLDA #7STA XC904 ;7 BYTES IN HEADERLDA #0JC428 JSR SC13A ;BBS DATA -> BUFFER $C900 ???LDA XC80D ;FLAG: 1ST BLOCK?BNE BC402 ;YES, SET $0200 = 0 & EXITJSR SC484 ;BLOCK CHECKSUM OK?BNE BC471.SKIP;BLOCK OK, SEND TO DISK;JSR CLRCHN ;I/O TO DEFAULTSLDA XC809 ;# BYTES IN BLOCKCMP #7 ;= 7 (JUST BLOCK HEADER)? ???BEQ BC455LDX #2JSR CHKOUT ;NO, READY CH 2 FOR OUTPUT (DISK)LDY #7BC446 LDA XC900,Y ;$C907 TO $C907+$C809 -> DISKJSR CHROUTINYCPY XC809BNE BC446JSR CLRCHN ;I/O TO DEFAULTS.PAGE;JUST "HEADER" OR SHORT BLOCK;BC455 LDA XC906CMP #$FF ;SHORT BLOCK? ???BNE BC464LDA #1STA XC80D ;FLAG: 1ST BLOCKLDA #'* ;PRINT "*".BYT $2CBC464 LDA #'- ;NO, PRINT "-"JSR CHROUTJSR SC59B ;ENABLE RS-232 BYTE RECEPTIONLDA #0 ;SEND "GOO"JMP JC428 ;GET NEXT BLOCK.SKIP;BLOCK CHECKSUM BAD;BC471 JSR CLRCHN ;I/O TO DEFAULTSLDA #': ;PRINT ":"JSR CHROUTLDA XC817 ;# BYTES RECEIVED ???STA XC904 ;SAVE IN BLOCK HEADERLDA #3 ;SEND "BAD"JMP JC428 ;TRY AGAIN.PAGE 'CHECKSUM 3';----------------------------------------;SC484: VERIFY CHECKSUM FOR BBS BLOCK;----------------------------------------.SKIP;ENTRY: $C900-C903 = BBS BLOCK CHECKSUM;EXIT:  IF .A = 0, CHECKSUM OK;          ''   1, BAD CHECKSUM.SKIPSC484 LDA XC900 ;CHECKSUM 1 - SUM OF BYTESSTA XC80ELDA XC901STA XC80FLDA XC902 ;CHECKSUM 2 - EOR OF BYTESSTA XC810LDA XC903STA XC811JSR SC364 ;SET $64/65 = $C900  ???LDA XC817 ;# BYTES IN BLOCKSTA XC809JSR SC380 ;COMPUTE BLOCK CHECKSUM @ $C900 ???LDA XC900 ;CHECKSUM OK?CMP XC80EBNE BC4CBLDA XC901CMP XC80FBNE BC4CBLDA XC902CMP XC810BNE BC4CBLDA XC903CMP XC811BNE BC4CBLDA #0 ;YES, SET .A = 0RTSBC4CB LDA #1 ;NO, SET .A = 1RTS.PAGE 'RECEIVE 1';========================================;SC4CE: RECEIVE 1;========================================.SKIP;EXIT: IF SHORT BLOCK, $0200 = 0.SKIPSC4CE LDA #0STA XC819 ;SET FLAGSSTA XC81ASTA XC80D ;FLAG: 1ST BLOCKSTA XC816 ;$64/65 = $C900STA XC80C ;DELAY COUNTERLDA #7CLCADC #1STA XC904 ;# BYTES TO SEND = 8 (HEADER+1)LDA #0 ;START HANDSHAKE = "GOO".SKIPJC4E9 JSR SC13A ;SEND HANDSHAKE, GET DATALDA XC80D ;FLAG: 1ST BLOCK?BNE BC511.SKIPJSR SC484 ;BLOCK CHECKSUM OK?BNE BC506 ;NOLDA XC907 ;1ST DATA BYTE OF BLOCKSTA XC81B ;= FILETYPELDA #1STA XC80D ;FLAG: 1ST BLOCK?LDA #0 ;SEND "GOO"JMP JC4E9 ;GET NEXT BLOCK.SKIP;BLOCK CHECKSUM BAD;BC506 LDA XC817 ;# BYTES RECEIVEDSTA XC904 ;SAVE IN HEADERLDA #3 ;SEND "BAD"JMP JC4E9 ;TRY AGAIN.SKIP;SHORT BLOCK ($C80D <> 0)  ???;BC511 LDA #0 ;SET FLAGSTA X0200RTS ;BACK TO BASIC.PAGE 'TRANSMIT 1';========================================;SC517: TRANSMIT 1;========================================.SKIP;EXIT: IF TRANSMIT OK, THEN $0200 = 0.SKIPSC517 LDA #0STA XC80D ;FLAG: 0 = 1ST BLOCKSTA XC80C ;SET DELAY COUNTER ???LDA #1STA XC816 ;SET $64/65 = $CA00STA XC81D ;SET SHORT BLOCK FLAG ???LDA #$FFSTA XC819 ;FLAG: TRANSMIT  ???STA XC81AJSR SC371 ;SET $64/65 = $C900LDY #4LDA #7CLCADC #1STA (Z64),Y ;$C904 = 8 (MIN # BYTES TO SEND)JSR SC364 ;SET $64/65 = $CA00LDY #5LDA #$FFSTA (Z64),Y ;$CA05 = $FFINYSTA (Z64),Y ;$CA06 = $FFLDY #7LDA XC81B ;FILE TYPESTA (Z64),Y ;$CA07 = FILE TYPE (1-3)LDA #1STA XC81E ;FLAG: WAIT FOR BBS "SYN"BC553 JSR SC1AC ;SEND BLOCK(S)BEQ BC553LDA #0STA X0200 ;FLAG: ???RTS ;BACK TO BASIC.SKIP 2;----------------------------------------;SC55E: TRANSMIT - DELAY EXIT  ???;----------------------------------------.SKIPSC55E INC XC80C ;SET @ 0 OR 1LDA XC80CCMP #3 ;< 3?BCC BC574LDA #0 ;NO, RESETSTA XC80CLDA XC80B ;DELAY FLAG SET?BEQ SC579 ;YES, DELAY & EXITBNE BC585 ;NO, JUST EXIT.SKIPBC574 LDA XC80B ;DELAY?BEQ BC585 ;NO, QUIT.PAGE 'MISC SUBS';----------------------------------------;SC579: DELAY;----------------------------------------.SKIPSC579 LDX #0 ;SET DELAY COUNTERSBC57B LDY #0BC57D INYBNE BC57DINXCPX #$78BNE BC57BBC585 RTS.SKIP 2;----------------------------------------;SC586: SEND BYTE   ???;----------------------------------------.SKIP;ENTRY: .A = BYTE TO SENT;EXIT:  .A =   ''    ''.SKIPSC586 PHA ;PRESERVE BYTELDA XC819 ;FLAG: $FF FOR XMIT ???ORA XC81ABEQ BC599 ;YES, EXITLDA XC80D ;FLAG: 1ST BLOCKBNE BC599 ;YES,  EXITPLAJSR CHROUT ;SEND BYTEPHABC599 PLA ;RESTORE BYTERTS.SKIP 2;========================================;SC59B: ENABLE RS-232 BYTE RECEPTION;========================================.SKIP;ENTRY: DEVICE 2 (MODEM) MUST BE OPENED.SKIPSC59B JSR RS2SET ;ENABLELDA X02A1 ;CHECK FOR INTERRUPTS...CMP #%10000000 ;NMI?BEQ SC59BCMP #%10010010 ;WAITING OR RECEIVING?BEQ SC59BRTS ;NONE OF THE ABOVE.PAGE 'TERMINAL MODE';========================================;SC5AA: TERMINAL MODE;========================================.SKIPSC5AA JSR SC667 ;PRINT CRSR, CHECK CMDR KEYBC5AD JSR SC0F1 ;GET RS-232 BYTELDA Z96 ;BYTE RECEIVED?BNE BC5C8LDA X0200 ;YES, GET BYTEAND #%01111111 ;MAKE IT 7-BITSTA X0200CMP #8 ;ASCII DELETE?BEQ BC5CBCMP #13 ;ASCII C/R?BEQ BC5CBCMP #32 ;ASCII SPACE?BPL BC5CB ;ANY OF THE ABOVE.SKIPBC5C8 JMP JC615 ;CHECK KEYBOARD.SKIPBC5CB CMP #$61 ;ASCII LOWERCASE ($61-7A)?BCC BC5DCCMP #$7BBCS BC5DCSEC ;YES, MAKE CBM LOWERCASE (-32)SBC #32STA X0200 ;SAVEJMP JC5EA.SKIPBC5DC CMP #$41 ;ASCII UPPERCASE ($41-5A)?BCC JC5EACMP #$5BBCS JC5EACLC ;YES, MAKE CBM UPPERCASE (+128)ADC #128STA X0200 ;SAVE.SKIPJC5EA CMP #8 ;DELETE?BNE BC5F3LDA #20 ;YES, SAVE CBM DELETESTA X0200BC5F3 CMP #34 ;QUOTES?BNE BC601JSR CHROUT ;YES, PRINT QUOTESLDA #20JSR CHROUT ;+ DELETELDA #34 ;SAVE QUOTESBC601 STA X0200CMP #13 ;C/R?BNE BC60FLDA #32JSR CHROUT ;YES, PRINT SPACE & C/RLDA #13BC60F JSR CHROUT ;PRINT CHARJSR SC667 ;PRINT CRSR, CMDR PRESSED?.SKIP;CHECK FOR KEYBOARD INPUT;JC615 JSR GETIN ;KEY PRESSED?BEQ BC5AD ;NO, CHECK RS-232STA X0200 ;YES, SAVE KEYBOARD CHARCMP #19 ;HOME?BEQ BC666 ;YES, EXIT TO BASICCMP #$41 ;CBM LOWERCASE ($41-5A)?BCC BC632CMP #$5BBCS BC632CLC ;YES, MAKE ASCII LOWERCASE (+32)ADC #32STA X0200JMP JC643.SKIPBC632 LDA X0200CMP #$C1 ;CBM UPPERCASE-2 ($C1-DA)?BCC JC643CMP #$DBBCS JC643SEC ;YES, MAKE ASCII UPPERCASE (-128)SBC #128STA X0200.SKIPJC643 CMP #20 ;CBM DELETE?BNE BC64CLDA #8 ;YES, MAKE ASCII BSSTA X0200BC64C CMP #$83 ;CBM SHIFT/STOP?BNE BC655LDA #16 ;YES, MAKE ASCII CONTROL PSTA X0200BC655 LDX #5JSR CHKOUT ;READY RS-232 FOR OUTPUTLDA X0200JSR CHROUT ;SEND BYTEJSR CLRCHN ;I/O TO DEFAULTSJMP SC5AA ;BACK TO START...BC666 RTS ;IF "HOME", EXIT TO BASIC.PAGE 'CRSR & CMDR';----------------------------------------;SC667: PRINT CRSR, CHECK IF CMDR PRESSED;----------------------------------------.SKIPSC667 LDA #18JSR CHROUT ;PRINT RVS ONLDA #32JSR CHROUT ;SPACELDA #157JSR CHROUT ;CRSR LEFTLDA #146JSR CHROUT ;AND RVS OFF.SKIP 2;----------------------------------------;SC67B: CHECK IF CMDR KEY PRESSED;----------------------------------------.SKIP;EXIT: X0200 = 1 (EXIT TO TERMINAL MODE).SKIPSC67B LDA X028DCMP #2 ;CMDR PRESSED?BNE BC689BC682 PLA ;YES, POP STACKTSXCPX XC81C ;TILL BASIC ENTRYBNE BC682BC689 LDA #1 ;SET FLAGSTA X0200